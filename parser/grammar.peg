{
package parser

// NB: including all the imports make the parser generator run a bit more quickly.
import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/maloquacious/wsj/ast"
)

// Note: Scripts are allowed to have a shebang ("#!") start their first line.
// The script runner checks for the shebang; if present it is replaced with "//"
// before the script is parsed. This is only allowed when running scripts from
// the command line; it is not supported in the REPL or when parsing fragments.

}

Program <- _ stmts:Statement* EOF {
    return &ast.Program{
        Statements: coerceStatementList(stmts),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Start of program
    }, nil
}

Statement <- s:IfStmt _ { return s, nil }
          / s:ForStmt _ { return s, nil }
          / s:ContinueStmt _ { return s, nil }
          / s:BreakStmt _ { return s, nil }
          / s:LetStmt _ { return s, nil }
          / s:AssignStmt _ { return s, nil }
          / s:BlockStmt _ { return s, nil }
          / s:ExprStmt _ { return s, nil }

LetStmt <- "let" _ name:Ident _ "=" _ value:Expression _ ";" {
    return &ast.LetStmt{
        Name: name.(*ast.Ident),
        Value: value.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "let" keyword
    }, nil
}

AssignStmt <- target:PostfixExpr _ "=" _ value:Expression _ ";" {
    return &ast.AssignStmt{
        Target: target.(ast.Expr),
        Value:  value.(ast.Expr),
        Pos: target.(ast.Expr).Position(), // Position of assignment target
    }, nil
}

IfStmt <- "if" _ "(" _ condition:Expression _ ")" _ thenStmt:BlockStmt elseClause:(_ "else" _ elseStmt:(IfStmt / BlockStmt))? {
    var elseStmt ast.Stmt
    if elseClause != nil {
        elseClauseSlice := elseClause.([]interface{})
        elseStmt = elseClauseSlice[3].(ast.Stmt) // skip whitespace, "else", whitespace
    }
    return &ast.IfStmt{
        Condition: condition.(ast.Expr),
        ThenStmt:  thenStmt.(ast.Stmt),
        ElseStmt:  elseStmt,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "if" keyword
    }, nil
}

ForStmt <- "for" _ "(" _ init:ForInitStmt _ ";" _ condition:Expression _ ";" _ update:ForUpdateStmt _ ")" _ body:Statement {
    return &ast.ForStmt{
        Init:      init.(ast.Stmt),
        Condition: condition.(ast.Expr),
        Update:    update.(ast.Stmt),
        Body:      body.(ast.Stmt),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "for" keyword
    }, nil
}

ForInitStmt <- "let" _ name:Ident _ "=" _ value:Expression {
    return &ast.LetStmt{
        Name: name.(*ast.Ident),
        Value: value.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "let" keyword
    }, nil
}
            / target:PostfixExpr _ "=" _ value:Expression {
    return &ast.AssignStmt{
        Target: target.(ast.Expr),
        Value:  value.(ast.Expr),
        Pos: target.(ast.Expr).Position(), // Position of assignment target
    }, nil
}
            / expr:Expression {
    return &ast.ExprStmt{
        Expr: expr.(ast.Expr),
        Pos: expr.(ast.Expr).Position(), // Position of expression
    }, nil
}

ForUpdateStmt <- target:PostfixExpr _ "=" _ value:Expression {
    return &ast.AssignStmt{
        Target: target.(ast.Expr),
        Value:  value.(ast.Expr),
        Pos: target.(ast.Expr).Position(), // Position of assignment target
    }, nil
}
             / expr:Expression {
    return &ast.ExprStmt{
        Expr: expr.(ast.Expr),
        Pos: expr.(ast.Expr).Position(), // Position of expression
    }, nil
}

ContinueStmt <- "continue" _ ";" {
    return &ast.ContinueStmt{
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "continue" keyword
    }, nil
}

BreakStmt <- "break" _ ";" {
    return &ast.BreakStmt{
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "break" keyword
    }, nil
}

BlockStmt <- "{" _ stmts:Statement* _ "}" {
    return &ast.BlockStmt{
        Statements: coerceStatementList(stmts),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of opening brace
    }, nil
}

Target <- base:Ident suffix:(_ "." _ Ident / _ "[" _ Expression _ "]")? {
    b := base.(*ast.Ident)
    if suffix == nil {
        return b, nil
    }

    pair := suffix.([]interface{})
    opBytes := pair[1].([]byte)
    op := string(opBytes)
    switch op { // Skip leading whitespace
    case ".":
        return &ast.MemberExpr{
            Object: b,
            Name:   pair[3].(*ast.Ident), // Skip whitespace around dot
            Pos:    b.Position(), // Position of base object
        }, nil
    case "[":
        return &ast.IndexExpr{
            Target: b,
            Index:  pair[3].(ast.Expr), // Skip whitespace and bracket
            Pos:    b.Position(), // Position of base target
        }, nil
    default:
        return nil, fmt.Errorf("unexpected suffix operator %v", op)
    }
}


ExprStmt <- e:Expression _ ";" {
    return &ast.ExprStmt{
        Expr: e.(ast.Expr),
        Pos: e.(ast.Expr).Position(), // Position of the expression
    }, nil
}

Expression <- or:LogicalOr {
    return or, nil
}

LogicalOr <- left:LogicalAnd rest:(( _ "||" _ ) right:LogicalAnd)* {
    base := left.(ast.Expr)
    if rest == nil {
        return base, nil
    }

    restList := rest.([]interface{})
    for _, item := range restList {
        pair := item.([]interface{})
        right := pair[1].(ast.Expr)
        
        base = &ast.BinaryExpr{
            Left:     base,
            Operator: "||",
            Right:    right,
            Pos:      base.Position(), // Position of left operand
        }
    }
    return base, nil
}

LogicalAnd <- left:Equality rest:(( _ "&&" _ ) right:Equality)* {
    base := left.(ast.Expr)
    if rest == nil {
        return base, nil
    }

    restList := rest.([]interface{})
    for _, item := range restList {
        pair := item.([]interface{})
        right := pair[1].(ast.Expr)
        
        base = &ast.BinaryExpr{
            Left:     base,
            Operator: "&&",
            Right:    right,
            Pos:      base.Position(), // Position of left operand
        }
    }
    return base, nil
}

Equality <- left:Comparison rest:(( _ "==" _ / _ "!=" _ ) right:Comparison)? {
    base := left.(ast.Expr)
    if rest == nil {
        return base, nil
    }

    pair := rest.([]interface{})
    opPair := pair[0].([]interface{})
    op := string(opPair[1].([]byte)) // Skip leading whitespace, convert bytes to string
    right := pair[1].(ast.Expr)

    return &ast.BinaryExpr{
        Left:     base,
        Operator: op,
        Right:    right,
        Pos:      base.Position(), // Position of left operand
    }, nil
}

Comparison <- left:Term rest:((_ ">=" _ / _ "<=" _ / _ ">" _ / _ "<" _) right:Term)? {
    l := left.(ast.Expr)
    if rest == nil {
        return l, nil
    }

    pair := rest.([]interface{})
    opPair := pair[0].([]interface{})
    op := string(opPair[1].([]byte)) // Skip leading whitespace, convert bytes to string
    r := pair[1].(ast.Expr)

    return &ast.BinaryExpr{
        Left:     l,
        Operator: op,
        Right:    r,
        Pos:      l.Position(), // Position of left operand
    }, nil
}

Term <- left:Factor rest:((_ "+" _ / _ "-" _) right:Factor)* {
    return foldLeftBinary(left, rest.([]interface{}))
}

Factor <- left:Unary rest:((_ "*" _ / _ "/" _ / _ "%" _) right:Unary)* {
    return foldLeftBinary(left, rest.([]interface{}))
}

Unary <- op:("-" / "!")? _ expr:PostfixExpr {
    e := expr.(ast.Expr)

    if op == nil {
        return e, nil
    }

    return &ast.UnaryExpr{
        Operator: op.(string),
        Expr:     e,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of operator
    }, nil
}

Primary <- l:Literal {
    return l, nil
} / i:Ident {
    return i, nil
} / "(" _ e:Expression _ ")" {
    return e, nil
}

PostfixExpr <- base:Primary rest:PostfixOp* {
    suffixes := coerceSuffixList(rest)
    return ast.ApplySuffixes(base.(ast.Expr), suffixes), nil
}

PostfixOp <- cs:CallOp {
    return cs, nil
} / is:IndexOp {
    return is, nil
} / ms:MemberOp {
    return ms, nil
}

CallOp <- "(" _ el:ExpressionList? _ ")" {
    return &ast.CallSuffix{
        Args: coerceExprList(el),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of opening parenthesis
    }, nil
}

IndexOp <- "[" _ e:Expression _ "]" {
    return &ast.IndexSuffix{
        Index: e.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of opening bracket
    }, nil
}

MemberOp <- "." _ i:Ident {
    return &ast.MemberSuffix{
        Name: i.(*ast.Ident),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of dot operator
    }, nil
}

ExpressionList <- first:Expression rest:(_ "," _ expr:Expression)* {
    list := []ast.Expr{first.(ast.Expr)}
    for _, item := range rest.([]interface{}) {
        pair := item.([]interface{})
        expr := pair[3].(ast.Expr) // skip whitespace, comma, whitespace
        list = append(list, expr)
    }
    return list, nil
}

Literal <- nl:Number {
    return nl, nil
} / s:String {
    return &ast.StringLiteral{
        Value: s.(string),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of string literal
    }, nil
} / "true" {
    return &ast.BoolLiteral{
        Value: true,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "true" literal
    }, nil
} / "false" {
    return &ast.BoolLiteral{
        Value: false,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "false" literal
    }, nil
} / "null" {
    return &ast.NullLiteral{
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of "null" literal
    }, nil
    return nil, nil
}

Number <- nl:Float { return nl, nil } / nl:Int { return nl, nil }

Float <- [0-9]+ "." [0-9]+ {
    f, err := strconv.ParseFloat(string(c.text), 64)
    return &ast.NumberLiteral{
        Value: f,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of float literal
    }, err
}

Int <- [0-9]+ {
    i, err := strconv.Atoi(string(c.text))
    return &ast.NumberLiteral{
        Value: int64(i),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of int literal
    }, err
}

Ident  <- [a-zA-Z] [a-zA-Z0-9_]* {
    text := string(c.text)
    switch text {
    case "let", "if", "else", "for", "continue", "break", "true", "false", "null":
        return nil, fmt.Errorf("reserved keyword %q cannot be used as identifier", text)
    }
    return &ast.Ident{
        Name: text,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col}, // Position of identifier
    }, nil
}

String <- "\"" ( [^"\\] / "\\" . )* "\"" {
    return string(c.text), nil
}

EOF <- !.

// Whitespace and Comments
_ <- ( [ \t\n\r] / Comment )*

Comment <- BlockComment / LineComment

BlockComment <- "/*" ( !"*/" . )* "*/"

LineComment <- "//" [^\n\r]* ( "\n" / "\r\n" / "\r" / EOF )
