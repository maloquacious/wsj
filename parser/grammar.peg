{
package parser

// NB: including all the imports make the parser generator run a bit more quickly.
import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/maloquacious/wsj/ast"
)

}

Program <- _ stmts:Statement* EOF {
    return &ast.Program{
        Statements: coerceStatementList(stmts),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

Statement <- s:LetStmt _ { return s, nil }
          / s:AssignStmt _ { return s, nil }
          / s:ExprStmt _ { return s, nil }

LetStmt <- "let" _ name:Ident _ "=" _ value:Expression _ ";" {
    return &ast.LetStmt{
        Name: name.(*ast.Ident),
        Value: value.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

AssignStmt <- target:Target _ "=" _ value:Expression _ ";" {
    return &ast.AssignStmt{
        Target: target.(ast.Expr),
        Value:  value.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

Target <- base:Ident suffix:(_ "." _ Ident / _ "[" _ Expression _ "]")? {
    b := base.(*ast.Ident)
    if suffix == nil {
        return b, nil
    }

    pair := suffix.([]interface{})
    switch pair[1] { // Skip leading whitespace
    case ".":
        return &ast.MemberExpr{
            Object: b,
            Name:   pair[3].(*ast.Ident), // Skip whitespace around dot
            Pos:    b.Position(), // or use c.Pos
        }, nil
    case "[":
        return &ast.IndexExpr{
            Target: b,
            Index:  pair[3].(ast.Expr), // Skip whitespace and bracket
            Pos:    b.Position(), // or use c.Pos
        }, nil
    default:
        return nil, fmt.Errorf("unexpected suffix operator %v", pair[1])
    }
}


ExprStmt <- e:Expression _ ";" {
    startOfExpression := e.(ast.Expr).Position()
    return &ast.ExprStmt{
        Expr: e.(ast.Expr),
        Pos: startOfExpression,
    }, nil
}

Expression <- eq:Equality {
    return eq, nil
}

Equality <- left:Comparison rest:(( _ "==" _ / _ "!=" _ ) right:Comparison)? {
    base := left.(ast.Expr)
    if rest == nil {
        return base, nil
    }

    pair := rest.([]interface{})
    opPair := pair[0].([]interface{})
    op := opPair[1].(string) // Skip leading whitespace
    right := pair[1].(ast.Expr)

    return &ast.BinaryExpr{
        Left:     base,
        Operator: op,
        Right:    right,
        Pos:      base.Position(), // or use op position if needed
    }, nil
}

Comparison <- left:Term rest:((_ ">" _ / _ "<" _ / _ ">=" _ / _ "<=" _) right:Term)? {
    l := left.(ast.Expr)
    if rest == nil {
        return l, nil
    }

    pair := rest.([]interface{})
    opPair := pair[0].([]interface{})
    op := opPair[1].(string) // Skip leading whitespace
    r := pair[1].(ast.Expr)

    return &ast.BinaryExpr{
        Left:     l,
        Operator: op,
        Right:    r,
        Pos:      l.Position(),
    }, nil
}

Term <- left:Factor rest:((_ "+" _ / _ "-" _) right:Factor)* {
    return foldLeftBinary(left, rest.([]interface{}))
}

Factor <- left:Unary rest:((_ "*" _ / _ "/" _ / _ "%" _) right:Unary)* {
    return foldLeftBinary(left, rest.([]interface{}))
}

Unary <- op:("-" / "!")? _ expr:PostfixExpr {
    e := expr.(ast.Expr)

    if op == nil {
        return e, nil
    }

    return &ast.UnaryExpr{
        Operator: op.(string),
        Expr:     e,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

Primary <- l:Literal {
    return l, nil
} / i:Ident {
    return i, nil
} / "(" _ e:Expression _ ")" {
    return e, nil
}

PostfixExpr <- base:Primary rest:PostfixOp* {
    suffixes := coerceSuffixList(rest)
    return ast.ApplySuffixes(base.(ast.Expr), suffixes), nil
}

PostfixOp <- cs:CallOp {
    return cs, nil
} / is:IndexOp {
    return is, nil
} / ms:MemberOp {
    return ms, nil
}

CallOp <- "(" _ el:ExpressionList? _ ")" {
    return &ast.CallSuffix{
        Args: coerceExprList(el),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

IndexOp <- "[" _ e:Expression _ "]" {
    return &ast.IndexSuffix{
        Index: e.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

MemberOp <- "." _ i:Ident {
    return &ast.MemberSuffix{
        Name: i.(*ast.Ident),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

// todo: Generalize callee to allow more than Ident
// If youâ€™re later supporting foo.bar() or (fn)(1), change callee:Ident to callee:Primary or PostfixExpr, e.g.:
//    CallExpr <- callee:Primary "(" args:ExpressionList? ")" {
// This allows more expressive calls like:
//    (foo.bar)(5)
//    (print)(1)

CallExpr <- callee:Ident _ "(" _ args:ExpressionList? _ ")" {
    var exprs []ast.Expr
    if args != nil {
        exprs = args.([]ast.Expr)
    } else {
        exprs = []ast.Expr{}
    }

    return &ast.CallExpr{
        Callee: callee.(ast.Expr),
        Args:   exprs,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

IndexExpr <- target:Primary _ "[" _ index:Expression _ "]" {
    return &ast.IndexExpr{
        Target: target.(ast.Expr),
        Index:  index.(ast.Expr),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

MemberExpr <- obj:Primary _ "." _ ident:Ident {
    return &ast.MemberExpr{
        Object: obj.(ast.Expr),
        Name:   ident.(*ast.Ident),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

ExpressionList <- first:Expression rest:(_ "," _ expr:Expression)* {
    list := []ast.Expr{first.(ast.Expr)}
    for _, item := range rest.([]interface{}) {
        pair := item.([]interface{})
        expr := pair[3].(ast.Expr) // skip whitespace, comma, whitespace
        list = append(list, expr)
    }
    return list, nil
}

Literal <- nl:Number {
    return nl, nil
} / s:String {
    return &ast.StringLiteral{
        Value: s.(string),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
} / "true" {
    return &ast.BoolLiteral{
        Value: true,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
} / "false" {
    return &ast.BoolLiteral{
        Value: false,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
} / "null" {
    return &ast.NullLiteral{
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
    return nil, nil
}

Number <- nl:Float { return nl, nil } / nl:Int { return nl, nil }

Float <- [0-9]+ "." [0-9]+ {
    f, err := strconv.ParseFloat(string(c.text), 64)
    return &ast.NumberLiteral{
        Value: f,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, err
}

Int <- [0-9]+ {
    i, err := strconv.Atoi(string(c.text))
    return &ast.NumberLiteral{
        Value: int64(i),
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, err
}

Ident  <- [a-zA-Z] [a-zA-Z0-9_]* {
    text := string(c.text)
    switch text {
    case "let", "true", "false", "null":
        return nil, fmt.Errorf("reserved keyword %q cannot be used as identifier", text)
    }
    return &ast.Ident{
        Name: text,
        Pos: ast.Pos{Line: c.pos.line, Column: c.pos.col},
    }, nil
}

String <- "\"" ( [^"\\] / "\\" . )* "\"" {
    return string(c.text), nil
}

EOF <- !.

// Whitespace and Comments
_ <- ( [ \t\n\r] / Comment )*

Comment <- BlockComment / LineComment

BlockComment <- "/*" ( !"*/" . )* "*/"

LineComment <- "//" [^\n\r]* ( "\n" / "\r\n" / "\r" / EOF )

// Legacy rules (kept for compatibility)
DIGIT <- [0-9]
LETTER <- [A-Z]
SP <- [ \t]+
